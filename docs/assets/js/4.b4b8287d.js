(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{184:function(e,t,r){e.exports=r.p+"assets/img/logo.c89bc3cb.svg"},188:function(e,t,r){"use strict";r.r(t);var s=r(0),a=Object(s.a)({},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"introduction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#introduction","aria-hidden":"true"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),s("p",{attrs:{align:"center"}},[s("img",{attrs:{src:r(184),width:"480px"}})]),e._v(" "),s("h2",{attrs:{id:"idea"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#idea","aria-hidden":"true"}},[e._v("#")]),e._v(" Idea")]),e._v(" "),s("p",[s("strong",[e._v("mug")]),e._v(" lets you create AWS Lambda for "),s("strong",[e._v("go")]),e._v(" projects directly integration "),s("strong",[e._v("DynamoDB")]),e._v(" if you wish so.")]),e._v(" "),s("p",[e._v("It boilerplates the project structure with a serverless framework configuration. Additionally a resource definition for Dynamo DB is generated, which creates a table for each resource to be added.")]),e._v(" "),s("h2",{attrs:{id:"how-it-works"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#how-it-works","aria-hidden":"true"}},[e._v("#")]),e._v(" How It Works")]),e._v(" "),s("p",[e._v("In general, there are three units that can be added to a project:")]),e._v(" "),s("ul",[s("li",[e._v("Resource")]),e._v(" "),s("li",[e._v("Function Group")]),e._v(" "),s("li",[e._v("Function")])]),e._v(" "),s("h3",{attrs:{id:"resource"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resource","aria-hidden":"true"}},[e._v("#")]),e._v(" Resource")]),e._v(" "),s("p",[e._v("A resource is defined as a model which implements basic CRUDL (Create, Read, Update, Delete, List) functions. Each resource will have its own DynamoDB table to persist the data. The model itself will be a go struct and can have nested structs as well, if defined upon creation.")]),e._v(" "),s("p",[e._v("The resource files will be stored in a directory named after the resource in the project's "),s("strong",[e._v("functions")]),e._v(" directory. It will look something like this e.g.:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("-rw-r--r-- course.json\n-rw-r--r-- course.go\n-rw-r--r-- serverless.yml\n-rw-r--r-- create/main.go\n-rw-r--r-- delete/main.go\n-rw-r--r-- list/main.go\n-rw-r--r-- read/main.go\n-rw-r--r-- update/main.go\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("ul",[s("li",[s("code",[e._v("course.json")]),e._v(" holds the resource configuration (e.g. attributes, key schema etc.)")]),e._v(" "),s("li",[s("code",[e._v("course.go")]),e._v(" is the model class containing the go struct and the "),s("strong",[e._v("CRUDL")]),e._v(" functions interacting with DynamoDB")]),e._v(" "),s("li",[s("code",[e._v("serverless.yml")]),e._v(" has the configuration for the deployment with serverless framework")]),e._v(" "),s("li",[s("code",[e._v("main.go")]),e._v(" files in the subdirectories are the Lambda handler functions calling the model`s methods")])]),e._v(" "),s("h3",{attrs:{id:"function-group"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-group","aria-hidden":"true"}},[e._v("#")]),e._v(" Function Group")]),e._v(" "),s("p",[e._v("A function group is - as the name might suggest - a group of functions. Unlike resource, it does not define a model or "),s("strong",[e._v("CRUDL")]),e._v(" functions but basically just helps to organize smaller functions. "),s("strong",[e._v("mug")]),e._v(" will generate a "),s("code",[e._v("serverless.yml")]),e._v(" file for the deployment.")]),e._v(" "),s("h3",{attrs:{id:"function"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function","aria-hidden":"true"}},[e._v("#")]),e._v(" Function")]),e._v(" "),s("p",[e._v("A function is a Lambda handler which can be added to either a "),s("em",[e._v("resource")]),e._v(" or a "),s("em",[e._v("function group")]),e._v(".\n"),s("strong",[e._v("mug")]),e._v(" will be able to deploy either a function group or a resource, so in case, you just want to deploy a single function, "),s("strong",[e._v("mug")]),e._v(" might not be the tool you are looking for, however, you would still accomplish this by first adding a function group and then adding a function to that group.")])])},[],!1,null,null,null);t.default=a.exports}}]);